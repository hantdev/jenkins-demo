pipeline {
  agent {
    kubernetes {
      // Sử dụng pod template với Kaniko container
      yaml """
        apiVersion: v1
        kind: Pod
        spec:
          containers:
            - name: kaniko
              image: gcr.io/kaniko-project/executor:latest
              command:
                - cat
              tty: true
              volumeMounts:
                - name: kaniko-secret
                  mountPath: /kaniko/.docker
              resources:
                requests:
                  memory: "256Mi"
                  cpu: "100m"
                limits:
                  memory: "1Gi"
                  cpu: "500m"
            
            - name: nodejs
              image: node:20-alpine
              command:
                - cat
              tty: true
              resources:
                requests:
                  memory: "256Mi"
                  cpu: "100m"
                limits:
                  memory: "1Gi"
                  cpu: "500m"
            
            - name: sonar-scanner
              image: sonarsource/sonar-scanner-cli:latest
              command:
                - cat
              tty: true
              resources:
                requests:
                  memory: "256Mi"
                  cpu: "100m"
                limits:
                  memory: "1Gi"
                  cpu: "500m"
            
            - name: gitleaks
              image: zricethezav/gitleaks:latest
              command:
                - cat
              tty: true
              resources:
                requests:
                  memory: "128Mi"
                  cpu: "50m"
                limits:
                  memory: "512Mi"
                  cpu: "200m"

          volumes:
            - name: kaniko-secret
              secret:
                secretName: kaniko-secret
        """
    }
  }

  environment {
    REGISTRY_URL = credentials('nexus-registry-url')
    REGISTRY_CREDS = credentials('nexus-docker-creds')
    IMAGE_NAME = 'jenkins-demo-app'
    IMAGE_TAG = "${env.BUILD_NUMBER}"

    // SonarQube server configured in Jenkins global settings with name 'sonarqube-server'
    // SonarQube token stored as secret text credential id 'sonarqube-token'
    SONARQUBE_ENV = 'sonarqube-server'
    SONAR_TOKEN = credentials('sonarqube-token')
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '20'))
    disableConcurrentBuilds()
    skipDefaultCheckout()  // Skip automatic checkout
  }

  stages {
    stage('Checkout') {
      steps {
        script {
          // Đảm bảo workspace là git repository và có thể fetch
          sh '''
            echo "Current directory: $(pwd)"
            echo "Contents: $(ls -la)"
            
            # Xóa workspace cũ nếu có vấn đề
            if [ -d .git ] && ! git status >/dev/null 2>&1; then
              echo "Corrupted git repository detected, removing..."
              rm -rf .git
            fi
            
            # Khởi tạo git repository nếu cần
            if [ ! -d .git ]; then
              echo "Initializing fresh git repository..."
              git init
              git config --global --add safe.directory /var/jenkins_home/workspace/jenkins-demo-pipeline
              git remote add origin https://github.com/hantdev/jenkins-demo.git
            fi
            
            # Fetch và checkout code
            echo "Fetching from remote repository..."
            git fetch origin main
            git checkout -f main
            git reset --hard origin/main
            
            echo "Git status after checkout:"
            git status
            echo "Current branch: $(git branch --show-current)"
          '''
        }
      }
    }

    stage('Gitleaks Scan') {
      steps {
        container('gitleaks') {
          sh '''
            gitleaks detect \
              --source . \
              --config .gitleaks.toml \
              --report-format json \
              --report-path gitleaks-report.json
          '''
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'gitleaks-report.json', allowEmptyArchive: true
        }
        unsuccessful {
          error 'Gitleaks found issues. Failing the build.'
        }
      }
    }

    stage('Install Dev Deps') {
      steps {
        container('nodejs') {
          sh '''
            npm ci
          '''
        }
      }
    }

    stage('Lint & Test') {
      steps {
        container('nodejs') {
          sh '''
            npm run lint
            npm test
          '''
        }
      }
      post {
        always {
          junit allowEmptyResults: true, testResults: 'junit.xml'
          archiveArtifacts artifacts: 'coverage/**', allowEmptyArchive: true
        }
      }
    }

    stage('SonarQube Scan') {
      environment {
        SONAR_SCANNER_OPTS = '-Xmx512m'
      }
      steps {
        container('sonar-scanner') {
          sh '''
            sonar-scanner \
              -Dsonar.host.url=http://10.10.2.200:30090 \
              -Dsonar.login=${SONAR_TOKEN} \
              -Dproject.settings=sonar-project.properties
          '''
        }
      }
    }

    stage('Build & Push Image with Kaniko') {
      steps {
        container('kaniko') {
          sh '''
            echo "Building and pushing Docker image with Kaniko..."
            echo "Registry URL: ${REGISTRY_URL}"
            echo "Image Name: ${IMAGE_NAME}"
            echo "Image Tag: ${IMAGE_TAG}"
            
            # Build và push image với Kaniko
            /kaniko/executor \
              --context `pwd` \
              --dockerfile `pwd`/Dockerfile \
              --destination=${REGISTRY_URL}/${IMAGE_NAME}:${IMAGE_TAG} \
              --destination=${REGISTRY_URL}/${IMAGE_NAME}:latest \
              --skip-tls-verify \
              --verbosity=info \
              --cache=true \
              --cache-ttl=24h
            
            echo "Image built and pushed successfully:"
            echo "  - ${REGISTRY_URL}/${IMAGE_NAME}:${IMAGE_TAG}"
            echo "  - ${REGISTRY_URL}/${IMAGE_NAME}:latest"
          '''
        }
      }
    }
  }

  post {
    always {
      echo 'Pipeline completed!'
    }
    success {
      echo 'Pipeline succeeded!'
    }
    failure {
      echo 'Pipeline failed!'
    }
  }
}
